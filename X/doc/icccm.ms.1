.\" Use tbl, eqn, -ms, and macros.t
.EH ''''
.OH ''''
.EF ''''
.OF ''''
.ps 11
.nr PS 11
.hw time-stamp
.\"
.\" --- bP --- bulleted paragraph macro
.\"
.de bP
.IP \(bu 4
..
.\"
.\" --- cT --- centered title; centers $1, adds TOC entry unless $2 is "no"
.\"
.de cT
\\&		\" filler so that the following .sp really leaves a space
.sp 1
.ce 1
\\s+1\\fB\\$1\\fP\\s-1
.sp 1
.if !'\\$2'no' \{\
.XS \\n(PN
\\$1
.XE
\}
..
.\"
.\" --- dA --- double arrow string
.\"
.ds dA "\o'\(<-\(->'
\&
.sp 8
.ce 9999
.B
\s+2Inter-Client Communication Conventions Manual\s0

.mc |
Version 2.0

Public Review Draft
(with change bars against version 1.1)

X Consortium Draft Standard
.R
.ce 0
.mc
.sp 6
.ce 9999
\s+1David Rosenthal\s0
.sp 6p
\s+1Sun Microsystems, Inc.\s0
.mc |
.sp 2
\s+1Version 2 edited by Stuart W. Marks\s0
.sp 6p
\s+1SunSoft, Inc.\s0
.ce 0
.mc
.bp
\&
.ps 9
.nr PS 9
.sp 8
.LP
X Window System is a trademark of M.I.T.
.LP             
.LP
Copyright \(co 1988, 1991, 1993
Massachusetts Institute of Technology, 
Cambridge, MA USA.
.LP
Copyright \(co 1987, 1988, 1989, 1993
Sun Microsystems, Inc
.LP 
Permission to use, copy, modify, and distribute this documentation 
for any purpose and without fee is hereby granted, provided 
that the above copyright notice and this permission 
notice appear in all copies.
MIT, Sun Microsystems, and the X Cosortium make no representations about the 
suitability for any purpose of the information in this document. 
This documentation is provided as is without express or implied warranty. 
This document is only a draft standard of the X Consortium and is therefore
subject to change.
.ps 11
.nr PS 11
.af PN i
.EF ''\\\\n(PN''
.OF ''\\\\n(PN''
.bp +4		\" the TOC is three pages long
.\" force preface onto odd page
.if e \{\
\&
.bp
\}
.cT "Preface to Version 2.0"
.LP
.mc |
The goal of the ICCCM Version 2.0 effort was to add new facilities, to fix
problems with earlier drafts, and to improve readability and
understandability, while maintaining compatibility with the earlier
versions.  This document is the product of over two years of discussion among
the members of the X Consortium's \fBwmtalk\fP working group.  The following
people deserve thanks for their contributions:
.LP
.Ds
.ta 3i
Gabe Beged-Dov	Bill Janssen
Chan Benson	Vania Joloboff
Jordan Brown	Phil Karlton
Larry Cable	Kaleb Keithley
Ellis Cohen	Mark Manasse
Donna Converse	Ralph Mor
Brian Cripe	Todd Newman
Susan Dahlberg	Bob Scheifler
Peter Daifuku	Keith Taylor
Andrew deBlois	Jim VanGilder
Clive Feather	Mike Wexler
Stephen Gildea	Michael Yee
Christian Jacobi
.De
.LP
It has been a privilege for me to work with this fine group of people.
.sp
Stuart W. Marks
.br
December 1993
.br
.mc
.bp
.cT "Preface to Version 1.1"
.LP
David Rosenthal had overall architectural responsibility 
for the conventions defined in this document;
he wrote most of the text and edited the document, 
but its the development has been a communal effort.
The details were thrashed out in meetings at the January 1988 MIT X Conference
and at the 1988 Summer Usenix conference,
and through months (and megabytes) of argument
on the
.PN wmtalk
mail alias.
Thanks are due to everyone who contributed,
and especially to the following people.
.LP
For the Selection section:
.LP
.Ds
Jerry Farrell
Phil Karlton
Loretta Guarino Reid
Mark Manasse
Bob Scheifler
.De
.LP
For the Cut-Buffer section:
.LP
.Ds
Andrew Palay.
.De
.LP
For the Window and Session Manager sections:
.LP
.Ds
.ta 3i
Todd Brunhoff	Matt Landau
Ellis Cohen	Mark Manasse
Jim Fulton	Bob Scheifler
Hania Gajewska	Ralph Swick
Jordan Hubbard	Mike Wexler
Kerry Kimbrough	Glenn Widener
Audrey Ishizaki	
.De
.LP
For the Device Color Characterization section:
.Ds
Keith Packard.
.De
.LP
In addition, thanks are due to those who contributed to the public review:
.LP
.Ds
.ta 3i
Gary Combs	John Irwin
Errol Crary	Vania Joloboff
Nancy Cyprych	John Laporta
John Diamant	Ken Lee
Clive Feather	Stuart Marks
Burns Fisher	Allan Mimms
Richard Greco	Colas Nahaboo
Tim Greenwood	Mark Patrick
Kee Hinckley	Steve Pitschke
Brian Holt	Brad Reed
John Interrante	John Thomas
.De
.bp 1
.af PN 1
.EH '\fBInter-Client Communication Conventions\fP''\fBPublic Review Draft\fP'
.OH '\fBInter-Client Communication Conventions\fP''\fBPublic Review Draft\fP'
.EF ''\fB % \fP''
.OF ''\fB % \fP''
.nH 1 Introduction
.LP
It was an explicit design goal of X Version 11 to specify mechanism,
not policy.
As a result,  
a client that converses with the server using the protocol defined 
by the \fIX Window System Protocol\fP, \fIVersion 11\fP may operate correctly 
in isolation but may not coexist properly with others sharing the same server.
.LP
Being a good citizen in the X Version 11 world involves adhering to
conventions that govern inter-client communications in the following areas:
.bP
Selection mechanism
.bP
Cut buffers
.bP
Window manager
.bP
Session manager
.bP
Manipulation of shared resources
.bP
Device color characterization
.LP
This document proposes suitable conventions without attempting to enforce 
any particular user interface.
To permit clients written in different languages to communicate,
these conventions are expressed solely in terms of protocol operations,
not in terms of their associated Xlib interfaces,
which are probably more familiar.
The binding of these operations to the Xlib interface for C
and to the equivalent interfaces for other languages
is the subject of other documents.
.nH 2 "Evolution of the Conventions"
.LP
In the interests of timely acceptance,
the \fIInter-Client Communication Conventions Manual\fP (ICCCM)
covers only a minimal set of required conventions.
These conventions will be added to and updated as appropriate,
based on the experiences of the X Consortium.
.LP
As far as possible,
these conventions are upwardly compatible with those in the February 25, 1988,
draft that was distributed with the X Version 11, Release 2 of the software.
In some areas,
semantic problems were discovered with those conventions,
and, thus, complete upward compatibility could not be assured.
These areas are noted in the text and are summarized in Appendix A.
.LP
In the course of developing these conventions,
a number of minor changes to the protocol were identified as desirable.
They also are identified in the text, are summarized in Appendix B,
and are offered as input to a future protocol revision process.
If and when a protocol revision incorporating these changes is undertaken,
it is anticipated that the ICCCM will need to be revised.
Because it is difficult to ensure that clients and servers are upgraded
simultaneously, 
clients using the revised conventions should examine the minor protocol 
revision number and be prepared to use the older conventions 
when communicating with an older server.
.LP
It is expected that these revisions will ensure that clients using 
the conventions appropriate to protocol minor revision \fIn\fP 
will interoperate correctly with those that use the conventions 
appropriate to protocol minor revision \fIn\fP+1 if the server supports both.
.nH 2 Atoms
.LP
Many of the conventions use atoms.
To assist the reader,
the following sections attempt to amplify the description of atoms 
that is provided in the protocol specification.
.nH 3 "What Are Atoms?"
.LP
At the conceptual level, 
atoms are unique names that clients can use to communicate information 
to each other.
They can be thought of as a bundle of octets,
like a string but without an encoding being specified.
The elements are not necessarily ASCII characters,
and no case folding happens.\**
.FS
The comment in the protocol specification for 
.PN InternAtom 
that ISO Latin-1 encoding should be used is in the nature of a convention;
the server treats the string as a byte sequence.
.FE
.LP
The protocol designers felt that passing these
sequences of bytes back and forth across the wire would be too costly.
Further, they thought it important that events 
as they appear \*Qon the wire\*U have a fixed size (in fact, 32 bytes)
and that because some events contain atoms, a fixed-size representation 
for them was needed.
.LP
To allow a fixed-size representation,
a protocol request 
.Pn ( InternAtom )
was provided to register a byte sequence with the server,
which returns a 32-bit value (with the top three bits zero) 
that maps to the byte sequence.
The inverse operator is also available 
.Pn ( GetAtomName ).
.nH 3 "Predefined Atoms"
.LP
The protocol specifies a number of atoms as being predefined:
.QP
Predefined atoms are not strictly necessary
and may not be useful in all environments,
but they will eliminate many 
.PN InternAtom
requests in most applications.
Note that they are predefined only in the sense of having numeric values, 
not in the sense of having required semantics.
.LP
Predefined atoms are an implementation trick to avoid the cost of interning
many of the atoms that are expected to be used during the startup phase 
of all applications.
The results of the 
.PN Intern\%Atom 
requests, which require a handshake, can be assumed \fIa priori\fP.
.LP
Language interfaces should probably cache the atom-name mappings 
and get them only when required.
The CLX interface, for instance, makes no distinction between predefined atoms
and other atoms; all atoms are viewed as symbols at the interface.
However, a CLX implementation will typically keep a symbol or atom cache 
and will typically initialize this cache with the predefined atoms.
.nH 3 "Naming Conventions"
.LP
The built-in atoms are composed of uppercase ASCII characters with the
logical words separated by an underscore character (_), for example,  
WM_ICON_NAME.
The protocol specification recommends that atoms used 
for private vendor-specific reasons should begin with an underscore.
To prevent conflicts among organizations, 
additional prefixes should be chosen 
(for example,  _DEC_WM_DECORATION_GEOMETRY).
.LP
The names were chosen in this fashion to make it easy to use them in a
natural way within LISP.
Keyword constructors allow the programmer to specify the atoms as LISP atoms.
If the atoms were not all uppercase,
special quoting conventions would have to be used.
.nH 3 Semantics
.LP
The core protocol imposes no semantics on atoms except as they are used in
FONTPROP structures.
For further information on FONTPROP semantics,
see the \fIX Logical Font Description Conventions\fP.
.nH 3 "Name Spaces"
.LP
The protocol defines six distinct spaces in which atoms are interpreted.
Any particular atom may or may not have some valid interpretation
with respect to each of these name spaces.
.br
.ne 6
.TS H
l l lw(3.6i).
_
.sp 6p
.B
Space	Briefly	Examples
.sp 6p
_
.sp 6p
.TH
.R
Property name	Name	WM_HINTS, WM_NAME, RGB_BEST_MAP, .\^.\^.
Property type	Type	WM_HINTS, CURSOR, RGB_COLOR_MAP, .\^.\^.
Selection name	Selection	PRIMARY, SECONDARY, CLIPBOARD
Selection target	Target	FILE_NAME, POSTSCRIPT, PIXMAP, .\^.\^.
Font property		QUAD_WIDTH, POINT_SIZE, .\^.\^.
T{
.PN ClientMessage
type
T}	T{
T}	T{
WM_SAVE_YOURSELF, _DEC_SAVE_EDITS, \&.\^.\^.
T}
.sp 6p
_
.TE
.nH 3 "Discriminated Names"
.mc |
.LP
Sometimes a protocol requires there to be an arbitrary number of similar
objects which need unique names (usually because the objects are created
dynamically, so that names cannot be invented in advance). For example, a
colormap-generating program might use the selection mechanism to offer
colormaps for each screen, and so needs a selection name for each screen.
Such names are called \*Qdiscriminated names\*U and are discriminated by
some entity. This entity can be:
.DS
    a screen
    an X resource (a window, a colormap, a visual, etc.)
    a client
.DE
.LP
If it is only necessary to generate a fixed set of names for each value
of the discriminating entity, then the discriminated names are formed by
suffixing an ordinary name according to the value of the entity.
.LP
If \fIname\fP is a descriptive portion for the name, \fId\fP is a decimal
number with no leading zeroes, and \fIx\fP is a hexadecimal number with
exactly 8 digits, and using uppercase letters, then such discriminated names
shall have the form:
.br
.ne 6
.TS
lB lB lB
l l l .
_
.sp 6p
Name Discriminated By	Form	Example
.sp 6p
_
.sp 6p
screen number	\fIname\fP_S\fId\fP	WM_COMMS_S2
X resource	\fIname\fP_R\fIx\fP	GROUP_LEADER_R1234ABCD
.sp 6p
_
.TE
.LP
To discriminate a name by client, use an X resource ID created by that
client.  This resource can be of any type.
.LP
Sometimes it is simply necessary to generate a unique set of names (for
example, for the properties on a window used by a MULTIPLE selection).
These names should have the form:
.DS
.ta 2i
U\fId\fP	(e.g.  U0  U1  U2  U3  .\^.\^.)
.DE
.LP
if the names stand totally alone, and the form:
.DS
.ta 2i
\fIname\fP_U\fId\fP	(e.g.  FOO_U0  BAR_U0  FOO_U1  BAR_U1  .\^.\^.)
.DE
.LP
if they come in sets (here there are two sets, named \*QFOO\*U and
\*QBAR\*U).  The stand-alone U\fId\fP form should only be used if it is
clear that the module using it has complete control over the relevant
namespace, or has the active cooperation of all other entities which might
also use these names. (Naming properties on a window created specifically
for a particular selection is such a use; naming properties on the root
window is almost certainly not.)
.LP
In a particularly difficult case, it might be necessary to combine both
forms of discrimination. If this happens, the U form should come after
the other form, thus:
.DS
    FOO_R12345678_U23
.DE
.mc
.NT Rationale
.mc |
Existing protocols will not be changed to use these naming conventions,
because doing so will cause too much disruption.  However, it is expected
that future protocols \(em both standard and private \(em will use these
conventions.
.NE
.mc
.nH 1 "Peer-to-Peer Communication by Means of Selections"
.LP
Selections are the primary mechanism that X Version 11 defines 
for the exchange of information between clients,
for example, by cutting and pasting between windows.
Note that there can be an arbitrary number of selections
(each named by an atom) and that they are global to the server.
Section 2.6 discusses the choice of an atom.
Each selection is owned by a client and is attached to a window.
.LP
Selections communicate between an owner and a requestor.
The owner has the data representing the value of its selection,
and the requestor receives it.
A requestor wishing to obtain the value of a selection provides the following:
.bP
The name of the selection
.bP
The name of a property
.bP
A window
.bP
The atom representing the data type required
.mc |
.bP
Optionally, some parameters for the request
.mc
.LP
If the selection is currently owned,
the owner receives an event and is expected to do the following:
.bP
Convert the contents of the selection to the requested data type
.bP
Place this data in the named property on the named window
.bP
Send the requestor an event to let it know the property is available
.LP
Clients are strongly encouraged to use this mechanism.
In particular,
displaying text in a permanent window without providing the ability 
to select and convert it into a string is definitely considered antisocial.
.LP
Note that all data transferred between an owner and a requestor must usually 
go by means of the server in an X Version 11 environment.
A client cannot assume that another client can open the same files
or even communicate directly.
The other client may be talking to the server by means of 
a completely different networking mechanism (for example,  one client might
be DECnet and the other TCP/IP).
Thus, passing indirect references to data 
(such as file names,  host names and port numbers, and so on) 
is permitted only if both clients specifically agree.
.nH 2 "Acquiring Selection Ownership"
.LP
A client wishing to acquire ownership of a particular selection
should call 
.PN SetSelectionOwner,
which is defined as follows:
.LP
.sM
.IN "SetSelectionOwner" "" "@DEF@"
.PN SetSelectionOwner
.in +.2i
.LP
\fIselection\fP\^: ATOM
.br
\fIowner\fP\^: WINDOW or
.PN None
.br
\fItime\fP\^: TIMESTAMP or
.PN CurrentTime
.in -.2i
.eM
.LP
The client should set the specified selection to the atom that represents 
the selection,
set the specified owner to some window that the client created,
and set the specified time to some time between the current last-change time 
of the selection concerned and the current server time.
This time value usually will be obtained from the timestamp of the event 
that triggers the acquisition of the selection.
Clients should not set the time
value to 
.PN CurrentTime ,
because if they do so, they have no way of finding
when they gained ownership of the selection.
Clients must use a window they created so that requestors
can route events to the owner of the selection.\**
.FS
At present, no part of the protocol requires requestors
to send events to the owner of a selection.
This restriction is imposed to prepare for possible future extensions.
.FE
.NT Convention
Clients attempting to acquire a selection must set the time value of the 
.PN Set\%Selection\%Owner 
request to the timestamp of the event triggering the acquisition attempt, 
not to 
.PN CurrentTime .
A zero-length append to a property is a way to obtain a timestamp for
this purpose;
the timestamp is in the corresponding 
.PN Property\%Notify
event.
.NE
.LP
If the time in the 
.PN SetSelectionOwner 
request is in the future relative to the server's current time 
or is in the past relative to the last time the specified selection 
changed hands, the 
.PN SetSelectionOwner
request appears to the client to succeed,
but ownership is not actually transferred.
.LP
Because clients cannot name other clients directly,
the specified owner window is used to refer to the owning client
in the replies to 
.PN GetSelectionOwner ,
in 
.PN SelectionRequest 
and
.PN SelectionClear
events, and possibly as a place to put properties describing the selection
in question.
To discover the owner of a particular selection,
a client should invoke
.PN GetSelectionOwner ,
which is defined as follows:
.LP
.sM
.IN "GetSelectionOwner" "" "@DEF@"
.PN GetSelectionOwner
.in +.2i
.LP
\fIselection\fP\^: ATOM
.in -.2i
.LP
\(->
.in +.2i
.LP
owner: WINDOW or
.PN None
.in -.2i
.eM
.NT Convention
Clients are expected to provide some visible confirmation
of selection ownership.
To make this feedback reliable,
a client must perform a sequence like the following:
.sp
.Ds 0
SetSelectionOwner(selection=PRIMARY, owner=Window, time=timestamp)
owner = GetSelectionOwner(selection=PRIMARY)
if (owner != Window) Failure
.De
.NE
.LP
If the 
.PN SetSelectionOwner
request succeeds (not merely appears to succeed),
the client that issues it is recorded by the server as being the owner 
of the selection for the time period starting at the specified time.
.mc *
.mc
.nH 2 "Responsibilities of the Selection Owner"
.LP
When a requestor wants the value of a selection,
the owner receives a 
.PN SelectionRequest
event, which is defined as follows:
.LP
.sM
.IN "SelectionRequest" "" "@DEF@"
.PN SelectionRequest
.in +.2i
.LP
\fIowner\fP\^: WINDOW
.br
\fIselection\fP\^: ATOM
.br
\fItarget\fP\^: ATOM
.br
\fIproperty\fP\^: ATOM or
.PN None
.br
\fIrequestor\fP\^: WINDOW
.br
\fItime\fP\^: TIMESTAMP or
.PN CurrentTime
.in -.2i
.eM
.LP
The specified owner and selection will be the values that were specified in
the
.PN SetSelection\%Owner 
request.
The owner should compare the timestamp with the period 
it has owned the selection and, if the time is outside,
refuse the 
.PN SelectionRequest 
by sending the requestor window a 
.PN SelectionNotify 
event with the property set to 
.PN None 
(by means of a
.PN SendEvent
request with an empty event mask).
.LP
More advanced selection owners are free to maintain a history
of the value of the selection and to respond to requests for the
value of the selection during periods they owned it
even though they do not own it now.
.LP
If the specified property is 
.PN None ,
the requestor is an obsolete client.
Owners are encouraged to support these clients by using the specified target
atom as the property name to be used for the reply.
.LP
Otherwise,
the owner should use the target to decide the form into which the selection
should be converted.
.mc |
Some targets may be defined such that requestors can pass parameters
along with the request.  The owner will find these parameters in the
property named in the selection request.  The type, format, and
contents of this property are dependent upon the definition of the
target.  If the target is not defined to have parameters, the owner
should ignore the property if it is present.
If the selection cannot be converted
into a form based on the target (and parameters, if any),
.mc
the owner should refuse the 
.PN Selection\%Request
as previously described.
.LP
If the specified property is not 
.PN None ,
the owner should place the data resulting from converting the selection 
into the specified property on the requestor window
and should set the property's type to some appropriate value,
which need not be the same as the specified target.
.NT Convention
All properties used to reply to 
.PN SelectionRequest
events must be placed on the requestor window.
.NE
.LP
In either case, 
if the data comprising the selection cannot be stored on the requestor window 
(for example, because the server cannot provide sufficient memory),
the owner must refuse the 
.PN SelectionRequest ,
as previously described.
See also section 2.5.
.LP
If the property is successfully stored,
the owner should acknowledge the successful conversion
by sending the requestor window a 
.PN SelectionNotify 
event (by means of a
.PN SendEvent
request with an empty mask).
.PN SelectionNotify
is defined as follows:
.LP
.sM
.IN "SelectionNotify" "" "@DEF@"
.PN SelectionNotify
.in +.2i
.LP
\fIrequestor\fP\^: WINDOW
.br
\fIselection\fP, \fItarget\fP\^: ATOM
.br
\fIproperty\fP\^: ATOM or
.PN None
.br
\fItime\fP\^: TIMESTAMP or
.PN CurrentTime
.in -.2i
.eM
.LP
The owner should set the specified selection, target, time, 
and property arguments to the values received in the 
.PN SelectionRequest 
event.
(Note that setting the property argument to 
.PN None 
indicates that the conversion requested could not be made.)
.NT Convention
The selection, target, time, and property arguments in the 
.PN SelectionNotify 
event should be set to the values received in the 
.PN SelectionRequest 
event.
.NE
.LP
.mc |
If the owner receives more than one
.PN Selection\%Request
event with the same requestor, selection, target, and timestamp, it must
respond to them in the same order in which they were received.
.mc
.NT Rationale
.mc |
It is possible for a requestor to have multiple outstanding requests that
use the same requestor window, selection, target, and timestamp, and that
differ only in the property.  If this occurs, and one of the conversion
requests fails, the resulting
.PN Selection\%Notify
event will have its property argument set to 
.PN None .
This may make it impossible for the requestor to determine which conversion
request had failed, unless the requests are responded to in order.
.NE
.mc
.LP
The data stored in the property must eventually be deleted.
A convention is needed to assign the responsibility for doing so.
.NT Convention
Selection requestors are responsible for deleting properties whose
names they receive in 
.PN SelectionNotify 
events (see section 2.4) or in properties with type MULTIPLE.
.NE
.LP
A selection owner will often need confirmation that the data comprising the
selection has actually been transferred.
(For example, 
if the operation has side effects on the owner's internal data structures, 
these should not take place until the requestor has indicated 
that it has successfully received the data.)
Owners should express interest in 
.PN PropertyNotify 
events for the specified requestor window 
and wait until the property in the 
.PN SelectionNotify 
.mc |
event has been deleted before assuming that the selection data has been
transferred.  For the MULTIPLE request, if the different conversions require
separate confirmation, the selection owner can also watch for the deletion
of the individual properties named in the property in the
.PN Selection\%Notify
event.
.mc
.LP
When some other client acquires a selection,
the previous owner receives a 
.PN SelectionClear 
event, which is defined as follows:
.LP
.sM
.IN "SelectionClear" "" "@DEF@"
.PN SelectionClear
.in +.2i
.LP
\fIowner\fP\^: WINDOW
.br
\fIselection\fP\^: ATOM
.br
\fItime\fP\^: TIMESTAMP
.in -.2i
.eM
.LP
The timestamp argument is the time at which the ownership changed hands,
and the owner argument is the window the previous owner specified in its
.PN SetSelectionOwner 
request.
.LP
If an owner loses ownership while it has a transfer in progress (that is,
before it receives notification that the requestor has received all the data),
it must continue to service the ongoing transfer until it is complete.
.LP
.mc |
If the selection value completely changes, but the owner happens
to be the same client (for example, selecting a totally different
piece of text in the same \fBxterm\fP as before), then the client should
reacquire the selection ownership as if it were not the owner,
providing a new timestamp. If the selection value is modified, but
can still reasonably be viewed as the same selected object,\** the
owner should take no action.
.FS
The division between these two cases is a matter of judgement
on the part of the software developer.
.FE
.mc
.nH 2 "Giving Up Selection Ownership"
.LP
Clients may either give up selection ownership voluntarily 
or lose it forcibly as the result of some other client's actions.
.nH 3 "Voluntarily Giving Up Selection Ownership"
.LP
To relinquish ownership of a selection voluntarily,
a client should execute a 
.PN SetSelection\%Owner
request for that selection atom, with owner specified as 
.PN None
and the time specified as the timestamp that was used to acquire the selection.
.LP
Alternatively,
the client may destroy the window used as the owner value of the 
.PN SetSelection\%Owner
request, or the client may terminate.
In both cases,
the ownership of the selection involved will revert to 
.PN None .
.nH 3 "Forcibly Giving Up Selection Ownership"
.LP
If a client gives up ownership of a selection
or if some other client executes a 
.PN SetSelection\%Owner 
for it and thus reassigns it forcibly,
the previous owner will receive a 
.PN Selection\%Clear 
event. For the definition of a 
.PN Selection\%Clear
event, see section 2.2.
.LP
The timestamp is the time the selection changed hands.
The specified owner is the window that was specified by the current owner 
in its 
.PN SetSelectionOwner
request.
.nH 2 "Requesting a Selection"
.LP
A client that wishes to obtain the value of a selection in a particular
form (the requestor) issues a 
.PN ConvertSelection 
request, which is defined as follows:
.LP
.sM
.IN "ConvertSelection" "" "@DEF@"
.PN ConvertSelection
.in +.2i
.LP
\fIselection\fP, \fItarget\fP\^: ATOM
.br
\fIproperty\fP\^: ATOM or
.PN None
.br
\fIrequestor\fP\^: WINDOW
.br
\fItime\fP\^: TIMESTAMP or
.PN CurrentTime
.in -.2i
.eM
.LP
The selection argument specifies the particular selection involved,
and the target argument specifies the required form of the information.
For information about the choice of suitable atoms to use,
see section 2.6.
The requestor should set the requestor argument to a window that it created;
the owner will place the reply property there.
The requestor should set the time argument to the timestamp on the event 
that triggered the request for the selection value.
Note that clients should not specify 
.PN CurrentTime .
.NT Convention
Clients should not use 
.PN CurrentTime 
for the time argument of a 
.PN ConvertSelection
request.
Instead, they should use the timestamp of the event that caused the request 
to be made.
.NE
.LP
The requestor should set the property argument to the name of a property 
that the owner can use to report the value of the selection.
.mc |
Requestors should ensure that the named property does not exist
on the window before issuing the
.PN Convert\%Selection
request.\** The exception to this rule is when the requestor intends to pass
parameters with the request; see below.
.mc
.NT Rationale
.mc |
It is necessary for requestors to delete the property before issuing the
request so that the target can later be extended to take parameters without
introducing an incompatibility.  Also note that the requestor of a selection
need not know the client that owns the selection nor the window on which
the selection was acquired.
.NE
.mc
.FS
This requirement is new in version 2.0, and in general, existing
clients do not conform to this requirement.  To prevent these clients
from breaking, no existing targets should be extended to take
parameters until sufficient time has passed for clients to be updated.
Note that the MULTIPLE target was defined to take parameters in version
1.0 and its definition is not changing.  There is thus no conformance
problem with MULTIPLE.
.FE
.LP
Some targets may be defined such that requestors can pass parameters
along with the request.  If the requestor wishes to provide parameters
to a request, they should be placed in the specified property on the
requestor window before the requestor issues the
.PN Convert\%Selection
request, and this property should be named in the request.
.LP
Some targets may be defined so that parameters are optional.  If no
parameters are to be supplied with the request of such a target, the
requestor must ensure that the property does not exist before issuing
the
.PN Convert\%Selection
request.
.LP
.mc
The protocol allows the property field to be set to 
.PN None ,
in which case the owner is supposed to choose a property name.
However, it is difficult for the owner to make this choice safely.
.NT Conventions
.IP 1. 5
Requestors should not use 
.PN None
for the property argument of a
.PN ConvertSelection
request.
.IP 2. 5
Owners receiving 
.PN ConvertSelection 
requests with a property argument of
.PN None
are talking to an obsolete client.
They should choose the target atom as the property name to be used 
for the reply.
.NE
.LP
The result of the 
.PN ConvertSelection
request is that a 
.PN SelectionNotify
event will be received.
For the definition of a
.PN SelectionNotify
event, see section 2.2.
.LP
The requestor, selection, time, and target arguments will be the same
as those on the 
.PN ConvertSelection 
request.
.LP
If the property argument is 
.PN None ,
the conversion has been refused.
This can mean either that there is no owner for the selection, 
that the owner does not support the conversion implied by the target,
or that the server did not have sufficient space to accommodate the data.
.LP
If the property argument is not 
.PN None ,
then that property will exist on the requestor window.
The value of the selection can be retrieved from this
property by using the 
.PN GetProperty
request, which is defined as follows:
.LP
.sM
.IN "GetProperty" "" "@DEF@"
.PN GetProperty
.in +.2i
.LP
\fIwindow\fP\^: WINDOW
.br
\fIproperty\fP\^: ATOM
.br
\fItype\fP\^: ATOM or
.PN AnyPropertyType
.br
\fIlong-offset\fP, \fIlong-length\fP\^: CARD32
.br
\fIdelete\fP\^: BOOL
.in -.2i
.LP
\(->
.in +.2i
.LP
type: ATOM or
.PN None
.br
format: {0, 8, 16, 32}
.br
bytes-after: CARD32
.br
value: LISTofINT8 or LISTofINT16 or LISTofINT32
.in -.2i
.eM
.LP
When using 
.PN GetProperty 
to retrieve the value of a selection,  
the property argument should be set to the corresponding value in the 
.PN SelectionNotify
event.
Because the requestor has no way of knowing beforehand what type 
the selection owner will use,
the type argument should be set to 
.PN AnyPropertyType .
Several 
.PN GetProperty 
requests may be needed to retrieve all the data in the selection;
each should set the long-offset argument to the amount of data received so far,
and the size argument to some reasonable buffer size (see section 2.5)..
If the returned value of bytes-after is zero,
the whole property has been transferred.
.LP
Once all the data in the selection has been retrieved
(which may require getting the values of several properties \(em
see section 2.7),
the requestor should delete the property in the 
.PN SelectionNotify
request by using a 
.PN GetProperty
request with the delete argument set to
.PN True .
As previously discussed,
the owner has no way of knowing when the data has been
transferred to the requestor unless the property is removed.
.NT Convention
The requestor must delete the property named in the 
.PN SelectionNotify
once all the data has been retrieved.
The requestor should invoke either 
.PN DeleteProperty 
or
.PN GetProperty (delete==True)
after it has successfully retrieved all the data in the selection.
For further information,
see section 2.5.
.NE
.nH 2 "Large Data Transfers"
.LP
Selections can get large, which poses two problems:
.bP
Transferring large amounts of data to the server is expensive.
.bP
All servers will have limits on the amount of data that can be stored
in properties.
Exceeding this limit will result in an 
.PN Alloc
error on the 
.PN ChangeProperty 
request that the selection owner uses to store the data.
.LP
The problem of limited server resources is addressed by the following
conventions:
.NT Conventions
.IP 1. 5
Selection owners should transfer the data describing a large selection
(relative to the maximum-request-size they received 
in the connection handshake) using the INCR property mechanism 
(see section 2.7.2).
.IP 2. 5
Any client using 
.PN SetSelectionOwner
to acquire selection ownership should arrange to process 
.PN Alloc
errors in property change requests.
For clients using Xlib,
this involves using the
.PN XSetErrorHandler
function to override the default handler.
.IP 3. 5
A selection owner must confirm that no 
.PN Alloc
error occurred while storing the properties for a selection 
before replying with a confirming 
.PN SelectionNotify
event.
.IP 4. 5
When storing large amounts of data (relative to maximum-request-size),
clients should use a sequence of 
.PN ChangeProperty (mode==Append)
requests for reasonable quantities of data.
This avoids locking servers up and limits the waste of data an
.PN Alloc 
error would cause.
.IP 5. 5
If an 
.PN Alloc 
error occurs during the storing of the selection data,
all properties stored for this selection should be deleted
and the 
.PN ConvertSelection
request should be refused (see section 2.2).
.IP 6. 5
To avoid locking servers up for inordinate lengths of time,
requestors retrieving large quantities of data from a property
should perform a series of 
.PN GetProperty 
requests, each asking for a reasonable amount of data.
.NE
.NT "Advice to Implementors"
.mc |
Single-threaded servers should take care to avoid locking up during large
data transfers.
.NE
.mc
.nH 2 "Use of Selection Atoms"
.LP
Defining a new atom consumes resources in the server
that are not released until the server reinitializes.
Thus, reducing the need for newly minted atoms is an important goal
for the use of the selection atoms.
.nH 3 "Selection Atoms"
.LP
There can be an arbitrary number of selections, each named by an atom.
To conform with the inter-client conventions, however,
clients need deal with only these three selections:
.bP
PRIMARY
.bP
SECONDARY
.bP
CLIPBOARD
.LP
Other selections may be used freely for private communication among
related groups of clients.
.mc *
.mc
.nH 4 "The PRIMARY Selection"
.LP
The selection named by the atom PRIMARY is used for all commands
that take only a single argument and is the principal means of communication 
between clients that use the selection mechanism.
.nH 4 "The SECONDARY Selection"
.LP
The selection named by the atom SECONDARY is used:
.bP
As the second argument to commands taking two arguments 
(for example, \*Qexchange primary and secondary selections\*U)
.bP
As a means of obtaining data when there is a primary selection
and the user does not want to disturb it
.nH 4 "The CLIPBOARD Selection"
.LP
The selection named by the atom CLIPBOARD is used to hold data
that is being transferred between clients, 
that is, data that usually is being cut or copied, and then pasted.
Whenever a client wants to transfer data to the clipboard:
.bP
It should assert ownership of the CLIPBOARD.
.bP
If it succeeds in acquiring ownership,
it should be prepared to respond to a request for the contents of the CLIPBOARD
in the usual way (retaining the data to be able to return it).
The request may be generated by the clipboard client described below.
.bP
If it fails to acquire ownership,
a cutting client should not actually perform the cut or provide feedback 
that would suggest that it has actually transferred data to the clipboard.
.LP
The owner should repeat this process whenever the data to be transferred
would change.
.LP
Clients wanting to paste data from the clipboard should request 
the contents of the CLIPBOARD selection in the usual way.
.LP
Except while a client is actually deleting or copying data,
the owner of the CLIPBOARD selection may be a single, special client
implemented for the purpose.
This client maintains the content of the clipboard up-to-date
and responds to requests for data from the clipboard as follows:
.bP
It should assert ownership of the CLIPBOARD selection
and reassert it any time the clipboard data changes.
.bP
If it loses the selection (because another client has some new data 
for the clipboard),
it should:
.RS
.IP \- 5
Obtain the contents of the selection from the new owner by using the timestamp
in the 
.PN SelectionClear
event.
.IP \- 5
Attempt to reassert ownership of the CLIPBOARD selection 
by using the same timestamp.
.IP \- 5
Restart the process using a newly acquired timestamp if this attempt fails.
This timestamp should be obtained by asking the current owner of the
CLIPBOARD selection to convert it to a TIMESTAMP.
If this conversion is refused or if the same timestamp is received twice,
the clipboard client should acquire a fresh timestamp in the
usual way (for example by a zero-length append to a property).
.RE
.bP
It should respond to requests for the CLIPBOARD contents in the usual way.
.LP
A special CLIPBOARD client is not necessary.
The protocol used by the cutting client and the pasting client
is the same whether the CLIPBOARD client is running or not.
The reasons for running the special client include:
.bP
Stability \- If the cutting client were to crash or terminate,
the clipboard value would still be available.
.bP
Feedback \- The clipboard client can display the contents of the clipboard.
.bP
Simplicity \- A client deleting data does not have to retain it for so long,
thus reducing the chance of race conditions causing problems.
.LP
The reasons not to run the clipboard client include:
.bP
Performance \- Data is only transferred if it is actually required 
(that is, when some client actually wants the data).
.bP
Flexibility \- The clipboard data may be available as more than one target.
.nH 3 "Target Atoms"
.LP
The atom that a requestor supplies as the target of a 
.PN ConvertSelection
request determines the form of the data supplied.
The set of such atoms is extensible, 
but a generally accepted base set of target atoms is needed.
As a starting point for this, 
the following table contains those that have been suggested so far.
.br
.ne 6
.\" This table has very tricky formatting.  Several targets are too long to
.\" fit, so the table format needs to change around them.  If the table
.\" format changes, it will need to be changed in several places.  There are
.\" also two footnotes in this table, but the footnote text can't be
.\" embedded in the table.  This means that the auto-numbering needs to be
.\" dinked around with after the end of the table.
.TS H
lw(1.8i) lw(1i) lw(3i) .
_
.sp 6p
.B
Atom	Type 	Data Received
.R
.sp 6p
_
.sp 6p
.TH
.T&
l s s .
ADOBE_PORTABLE_DOCUMENT_FORMAT
.T&
lw(1.8i) lw(1i) lw(3i) .
	STRING	T{
.mc |
[1]
.mc
T}
.sp 6p
APPLE_PICT	APPLE_PICT	T{
.mc |
[2]
.mc
T}
BACKGROUND	PIXEL	A list of pixel values
BITMAP	BITMAP	A list of bitmap IDs
CHARACTER_POSITION	SPAN	T{
The start and end of the selection in bytes
T}
CLASS	TEXT	(see section 4.1.2.5)
CLIENT_WINDOW	WINDOW	T{
.mc |
Any top-level window owned by the selection owner
.mc
T}
COLORMAP	COLORMAP	A list of colormap IDs
COLUMN_NUMBER	SPAN	T{
The start and end column numbers
T}
COMPOUND_TEXT	COMPOUND_TEXT	Compound Text
DELETE	NULL	(see section 2.6.3.1)
DRAWABLE	DRAWABLE	A list of drawable IDs
.sp 6p
.T&
l s s .
ENCAPSULATED_POSTSCRIPT
.T&
lw(1.8i) lw(1i) lw(3i) .
	STRING	T{
.mc |
[3], Appendix H\|\**
.mc
T}
.sp 6p
.T&
l s s .
ENCAPSULATED_POSTSCRIPT_INTERCHANGE
.T&
lw(1.8i) lw(1i) lw(3i) .
	STRING	T{
.mc |
[3], Appendix H
.mc
T}
.sp 6p
FILE_NAME	TEXT	The full path name of a file
FOREGROUND	PIXEL	A list of pixmap values
HOST_NAME	TEXT	(see section 4.1.2.9)
INSERT_PROPERTY	NULL	(see section 2.6.3.3)
INSERT_SELECTION	NULL	(see section 2.6.3.2)
LENGTH	INTEGER	T{
.mc |
The number of bytes in the selection\|\**
.mc
T}
LINE_NUMBER	SPAN	T{
The start and end line numbers
T}
LIST_LENGTH	INTEGER	T{
The number of disjoint parts of the selection
T}
MODULE	TEXT	T{
The name of the selected procedure
T}
MULTIPLE	ATOM_PAIR	T{
(see the discussion that follows)
T}
NAME	TEXT	(see section 4.1.2.1)
ODIF	TEXT	T{
ISO Office Document Interchange Format
T}
OWNER_OS	TEXT	T{
The operating system of the owner client
T}
PIXMAP	DRAWABLE	A list of pixmap IDs
POSTSCRIPT	STRING	T{
.mc |
[3]
.mc
T}
PROCEDURE	TEXT	T{
The name of the selected procedure
T}
PROCESS	INTEGER, TEXT	T{
The process ID of the owner
T}
STRING	STRING	ISO Latin-1 (+TAB+NEWLINE) text
TARGETS	ATOM	A list of valid target atoms
TASK	INTEGER, TEXT	T{
The task ID of the owner
T}
TEXT	TEXT	T{
The text in the owner's choice of encoding
T}
TIMESTAMP	INTEGER	T{
The timestamp used to acquire the selection
T}
USER	TEXT	T{
The name of the user running the owner
T}
.sp 6p
_
.TE
.\" Hack!  There are two footnotes in the table above, which increments
.\" the footnote counter (number register *) once too many times.  We
.\" decrement it before the first footnote, and increment it after.
.nr * \n*-1
.FS
The targets ENCAPSULATED_POSTSCRIPT and ENCAPSULATED_POSTSCRIPT_INTERCHANGE
are equivalent to the targets _ADOBE_EPS and _ADOBE_EPSI (respectively) that
appear in the selection targets registry.  The _ADOBE_ targets are
deprecated, but clients are encouraged to continue to support them for
backward compatibility.
.FE
.nr * \n*+1
.FS
This definition is ambiguous, as the selection may be converted into any of
several targets which may return differing amounts of data.  The requestor
has no way of knowing which, if any, of these targets corresponds to the
result of LENGTH.  Clients are advised that no guarantees can be made about
the result of a conversion to LENGTH; its use is thus deprecated.
.FE
.LP
.mc |
References:
.IP [1] 5
Adobe Systems, Incorporated.
.I
Portable Document Format Reference Manual.
.R
Addison-Wesley, ISBN 0-201-62628-4.
.IP [2] 5
Apple Computer, Incorporated.
.I
Inside Macintosh, Volume V.
.R
Chapter 4, \*QColor QuickDraw,\*U Color \%Picture Format.
ISBN 0-201-17719-6.
.IP [3] 5
Adobe Systems, Incorporated.
.I
PostScript Language Reference Manual.
.R
Addison-Wesley, ISBN 0-201-18127-4.
.mc
.LP
It is expected that this table will grow over time.
.LP
Selection owners are required to support the following targets.
All other targets are optional.
.bP
TARGETS \- The owner should return a list of atoms that represent
the targets for which an attempt to convert the current selection
will succeed (barring unforseeable problems such as 
.PN Alloc 
errors).
This list should include all the required atoms.
.bP
MULTIPLE \- The MULTIPLE target atom is valid only when a property 
is specified on the 
.PN ConvertSelection 
request.
If the property argument in the 
.PN SelectionRequest 
event is 
.PN None 
and the target is MULTIPLE, 
it should be refused.
.IP
When a selection owner receives a 
.PN SelectionRequest (target==MULTIPLE)
request,
the contents of the property named in the request will be a list of atom pairs:
the first atom naming a target and the second naming a property 
.Pn ( None 
is not valid here).
The effect should be as if the owner had received a sequence of
.PN SelectionRequest 
events (one for each atom pair) except that:
.RS
.IP \- 5
The owner should reply with a 
.PN SelectionNotify 
only when all the requested conversions have been performed.
.IP \- 5
.mc |
If the owner fails to convert the target named by an atom 
.mc
in the MULTIPLE property,
it should replace that atom in the property with
.PN None .
.RE
.NT Convention
The entries in a MULTIPLE property must be processed in the order
they appear in the property.
For further information,
see section 2.6.3.
.NE
.mc |
.RS
.LP
The requestor should delete each individual property when it has
copied the data from that conversion, and the property specified in the
MULTIPLE request when it has copied all the data.
.LP
The requests are otherwise to be processed independently, and they
should succeed or fail independently.  The MULTIPLE target is an
optimization that reduces the amount of protocol traffic between the
owner and the requestor; it is not a transaction mechanism.  For
example, a client may issue a MULTIPLE request with two targets: a data
target and the DELETE target.  The DELETE target will still be processed
even if the conversion of the data target fails.
.RE
.mc
.bP
TIMESTAMP \- To avoid some race conditions,
it is important that requestors be able to discover the timestamp 
the owner used to acquire ownership.
Until and unless the protocol is changed so that a
.PN GetSelectionOwner
request returns the timestamp used to acquire ownership,
selection owners must support conversion to TIMESTAMP,
returning the timestamp they used to obtain the selection.
.mc *
.mc
.nH 3 "Selection Targets with Side Effects"
.LP
Some targets (for example, DELETE) have side effects.
To render these targets unambiguous,
the entries in a MULTIPLE property must be processed in the order 
that they appear in the property.
.LP
In general,
targets with side effects will return no information,
that is, they will return a zero-length property of type NULL.
(Type NULL means the result of
.PN InternAtom
.mc |
on the string \*QNULL\*U, not the value zero.)
.mc
In all cases,
the requested side effect must be performed before the conversion is accepted.
If the requested side effect cannot be performed,
the corresponding conversion request must be refused.
.NT Conventions
.IP 1. 5
Targets with side effects should return no information
(that is, they should have a zero-length property of type NULL).
.IP 2. 5
The side effect of a target must be performed before the conversion is accepted.
.IP 3. 5
If the side effect of a target cannot be performed,
the corresponding conversion request must be refused.
.NE
.RE
.NT Problem
The need to delay responding to the 
.PN ConvertSelection 
request until a further conversion has succeeded poses problems 
for the Intrinsics interface that need to be addressed.
.NE
.LP
These side effect targets are used to implement operations such as
\*Qexchange PRIMARY and SECONDARY selections.\*U
.nH 4 "DELETE"
.LP
When the owner of a selection receives a request to convert it to DELETE,
it should delete the corresponding selection
(whatever doing so means for its internal data structures)
and return a zero-length property of type NULL if the deletion was successful.
.nH 4 "INSERT_SELECTION"
.LP
When the owner of a selection receives a request to convert it to 
INSERT_SELECTION,
the property named will be of type ATOM_PAIR.
The first atom will name a selection,
and the second will name a target.
The owner should use the selection mechanism to convert the named selection
into the named target and should insert it at the location of the selection
for which it got the INSERT_SELECTION request
(whatever doing so means for its internal data structures).
.nH 4 "INSERT_PROPERTY"
.LP
When the owner of a selection receives a request to convert it to
INSERT_PROPERTY, 
it should insert the property named in the request at the location 
of the selection for which it got the INSERT_SELECTION request
(whatever doing so means for its internal data structures).
.nH 2 "Use of Selection Properties"
.LP
The names of the properties used in selection data transfer are chosen by
the requestor.
The use of 
.PN None 
property fields in 
.PN ConvertSelection 
requests (which request the selection owner to choose a name)
is not permitted by these conventions.
.LP
The selection owner always chooses the type of the property 
in the selection data transfer.
Some types have special semantics assigned by convention,
and these are reviewed in the following sections.
.LP
In all cases,
a request for conversion to a target should return either
.mc |
a property of one of the types listed in the previous table for that target
.mc
or a property of type INCR and then a property of one of the listed types.
.LP
.mc |
Certain selection properties may contain resource IDs.  The selection owner
should ensure that the resource is not destroyed and that its contents are
not changed until after the selection transfer is complete.  Requestors that
rely on the existence or on the proper contents of a resource must operate
on the resource (for example, by copying the contents of a pixmap) before
deleting the selection property.
.LP
.mc
The selection owner will return a list of zero or more items
of the type indicated by the property type.
In general,
the number of items in the list will correspond to the number 
of disjoint parts of the selection.
Some targets (for example, side-effect targets) will be of length zero
irrespective of the number of disjoint selection parts.
In the case of fixed-size items,
the requestor may determine the number of items by the property size.
.mc |
Selection property types are listed in the table below.
For variable-length items such as text, 
the separators are also listed.
.mc
.br
.ne 6
.TS H
l c l.
_
.sp 6p
.B
Type Atom	Format	Separator
.R
.sp 6p
_
.sp 6p
.TH
APPLE_PICT	8	T{
.mc |
Self-sizing
.mc
T}
ATOM	32	Fixed-size
ATOM_PAIR	32	Fixed-size
BITMAP	32	Fixed-size
C_STRING	8	T{
.mc |
Zero
.mc
T}
COLORMAP	32	T{
.mc |
Fixed-size
.mc
T}
COMPOUND_TEXT	8	Zero
DRAWABLE	32	Fixed-size
INCR	32	Fixed-size
INTEGER	32	Fixed-size
PIXEL	32	T{
.mc |
Fixed-size
.mc
T}
PIXMAP	32	Fixed-size
SPAN	32	Fixed-size
STRING	8	Zero
WINDOW	32	Fixed-size
.sp 6p
_
.TE
.LP
It is expected that this table will grow over time.
.nH 3 "TEXT Properties"
.LP
In general, 
the encoding for the characters in a text string property is specified 
by its type.
It is highly desirable for there to be a simple, invertible mapping 
between string property types and any character set names
embedded within font names in any font naming standard adopted by the
Consortium.
.LP
The atom TEXT is a polymorphic target.
Requesting conversion into TEXT will convert into whatever encoding 
is convenient for the owner.
The encoding chosen will be indicated by the type of the property returned.
TEXT is not defined as a type;
it will never be the returned type from a selection conversion request.
.LP
If the requestor wants the owner to return the contents of the selection
in a specific encoding,
it should request conversion into the name of that encoding.
.LP
In the table in section 2.6.2,
the word TEXT (in the Type column) is used to indicate one 
of the registered encoding names.
The type would not actually be TEXT;
it would be STRING or some other ATOM naming the encoding chosen by the owner.
.LP
STRING as a type or a target specifies the ISO Latin-1 character set plus the
control characters TAB (octal 11) and NEWLINE (octal 12).
The spacing interpretation of TAB is context dependent.
Other ASCII control characters are explicitly not included in STRING 
at the present time.
.LP
COMPOUND_TEXT as a type or a target specifies the Compound Text interchange
format; see the \fICompound Text Encoding\fP.
.LP
.mc |
There are some text objects where the source or intended user, as the
case may be, does not have a specific character set for the text, but
instead merely requires a zero-terminated sequence of bytes with no
other restriction; no element of the selection mechanism may assume that
any byte value is forbidden or that any two differing sequences are
equivalent.\**  For these objects, the type C_STRING should be used.
.mc
.FS
Note that this is different from STRING, where many byte values are
forbidden, and from COMPOUND_TEXT, where, for example, inserting the
sequence 27,\ 40,\ 66 (designate ASCII into GL) at the start does not alter
the meaning.
.FE
.NT Rationale
.mc |
An example of the need for C_STRING is to transmit the names of
files; many operating systems do not interpret filenames as having
a character set. For example, the same character string uses a
different sequence of bytes in ASCII and EBCDIC, and so most
operating systems see these as different filenames, and offer no
way to treat them as the same. Thus no character-set based
property type is suitable.
.NE
.mc
.LP
.mc |
Type STRING, COMPOUND_TEXT, and C_STRING properties will consist of a list
of elements separated by null characters; other encodings will need to
specify an appropriate list format.
.mc
.nH 3 "INCR Properties"
.LP
Requestors may receive a property of type INCR\**
in response to any target that results in selection data.
.FS
These properties were called INCREMENTAL in an earlier draft.
The protocol for using them has changed, 
and so the name has changed to avoid confusion.
.FE
This indicates that the owner will send the actual data incrementally.
The contents of the INCR property will be an integer,  
which represents a lower bound on the number of bytes of data in the selection.
The requestor and the selection owner transfer the data in the selection 
in the following manner.
.LP
The selection requestor starts the transfer process by deleting
the (type==INCR) property forming the reply to the selection.
.LP
The selection owner then:
.bP
Appends the data in suitable-size chunks to the
same property on the same window as the selection reply
with a type corresponding to the actual type of the converted selection.
The size should be less than the maximum-request-size in the connection
handshake.
.bP
Waits between each append for a 
.PN PropertyNotify (state==Deleted) 
event that shows that the requestor has read the data.
The reason for doing this is to limit the consumption of space in the server.
.bP
Waits (after the entire data has been transferred to the server) until a 
.PN PropertyNotify (state==Deleted)
event that shows that the data has been read by the requestor
and then writes zero-length data to the property.
.LP
The selection requestor:
.bP
Waits for the 
.PN SelectionNotify 
event.
.bP
Loops:
.RS
.IP \- 5
Retrieving data using 
.PN GetProperty 
with the delete argument
.PN True .
.IP \- 5
Waiting for a 
.PN PropertyNotify 
with the state argument 
.PN NewValue .
.RE
.bP
Waits until the property named by the
.PN PropertyNotify
event is zero-length.
.bP
Deletes the zero-length property.
.LP
The type of the converted selection is the type of the first partial property.
The remaining partial properties must have the same type.
.nH 3 "DRAWABLE Properties"
.LP
Requestors may receive properties of type PIXMAP, BITMAP, DRAWABLE, or WINDOW,
which contain an appropriate ID.
While information about these drawables is available from the server by means of
the 
.PN GetGeometry 
request,
the following items are not:
.bP
Foreground pixel
.bP
Background pixel
.bP
Colormap ID
.LP
In general,
requestors converting into targets whose returned type in the table 
in section 2.6.2 is one of the DRAWABLE types should expect to convert also 
into the following targets (using the MULTIPLE mechanism):
.bP
FOREGROUND returns a PIXEL value.
.bP
BACKGROUND returns a PIXEL value.
.bP
COLORMAP returns a colormap ID.
.nH 3 "SPAN Properties"
.LP
Properties with type SPAN contain a list of cardinal-pairs
with the length of the cardinals determined by the format.
The first specifies the starting position,
and the second specifies the ending position plus one.
The base is zero.
If they are the same,
the span is zero-length and is before the specified position.
The units are implied by the target atom, 
such as LINE_NUMBER or CHARACTER_POSITION.
.nH 2 "Manager Selections"
.mc |
.LP
Certain clients, often called managers, take on responsibility
for managing shared resources.  A client that manages a shared
resource should take ownership of an appropriate selection,
named using the conventions described in sections 1.2.3
and 1.2.6.  A client that manages multiple
shared resources (or groups of resources) should take
ownership of a selection for each one.
.LP
The manager may support conversion of various targets
for that selection.  Managers are encouraged to use this
technique as the primary means by which clients interact
with the managed resource.  Note that the conventions for
interacting with the window manager predate this section;
as a result many interactions with the window manager use
other techniques.
.LP
Before a manager takes ownership of a manager selection, it
should use the
.PN GetSelection\%Owner
request to check whether the selection is already owned by another client,
and where appropriate, it should ask the user if the new manager should
replace the old one.  If so, it may then take ownership of the selection.
Managers should acquire the selection using a window created expressly for
this purpose.  Managers must conform to the rules for selection owners
described in sections 2.1 and 2.2, and they must also support the required
targets listed in section 2.6.2.
.LP
If a manager loses ownership of a manager selection, this
means that a new manager is taking over its responsibilities.
The old manager must release all resources it has managed,
and must then destroy the window that owned the selection.
For example, a window manager losing ownership of WM_S2
must deselect from
.PN SubstructureRedirect
on the root window of screen 2 before destroying the window that owned
WM_S2.
.LP
When the new manager notices that the window owning the selection
has been destroyed, it knows that it can successfully proceed to
control the resource it is planning to manage.  If the old
manager does not destroy the window within a reasonable time,
the new manager should check with the user before destroying
the window itself or killing the old manager.
.LP
If a manager wants to give up, on its own, management of a shared
resource controlled by a selection, it must do so by releasing
the resources it is managing, and then by destroying the
window that owns the selection.  It should not first disown
the selection, since this introduces a race condition.
.LP
Clients who are interesting in knowing when the owner of a
manager selection is no longer managing the corresponding shared
resource should select for
.PN StructureNotify
on the window owning the selection so they can be notified when the window
is destroyed.  Clients are warned that after doing a
.PN GetSelectionOwner
and selecting for
.PN StructureNotify ,
they should do a
.PN GetSelectionOwner
again to ensure that the owner did not change after initially getting the
selection owner and before selecting for 
.PN StructureNotify .
.LP
Immediately after a manager successfully acquires ownership of a
manager selection, it should announce its arrival by sending a
.PN ClientMessage
event.  This event should be sent using the
.PN SendEvent
protocol request with the following arguments:
.br
.mc
.ne 6
.TS
l lw(4.5i) .
_
.sp 6p
.B
Argument	Value
.R
.sp 6p
_
.sp 6p
.mc |
destination:	T{
the root window of screen 0, or the root
window of the appropriate screen if the
manager is managing a screen-specific resource
T}
propagate:	False
event-mask:	T{
.PN StructureNotify
T}
event:	T{
.PN ClientMessage
T}
\h'4n'type:	MANAGER
\h'4n'format:	32
\h'4n'data[0]:\**	timestamp
\h'4n'data[1]:	manager selection atom
\h'4n'data[2]:	the window owning the selection
\h'4n'data[3]:	manager-selection-specific data
\h'4n'data[4]:	manager-selection-specific data
.mc
.sp 6p
_
.TE
.FS
We use the notation data[n] to indicate the n\s-2\uth\d\s0 element 
of the LISTofINT8, LISTofINT16, or LISTofINT32 in the data field of the 
.PN ClientMessage ,
according to the format field.
The list is indexed from zero.
.FE
.LP
.mc |
Clients that wish to know when a specific manager has started should
select for
.PN Structure\%Notify
on the appropriate root window, and should watch for the appropriate MANAGER
.PN Client\%Message .
.mc
.nH 1 "Peer-to-Peer Communication by Means of Cut Buffers"
.LP
The cut buffer mechanism is much simpler but much less powerful 
than the selection mechanism.
The selection mechanism is active in that it provides a link 
between the owner and requestor clients.
The cut buffer mechanism is passive;
an owner places data in a cut buffer from which a requestor retrieves
the data at some later time.
.LP
The cut buffers consist of eight properties on the root of screen zero,
named by the predefined atoms CUT_BUFFER0 to CUT_BUFFER7.
These properties must, at present, have type STRING and format 8.
A client that uses the cut buffer mechanism must initially ensure that
all eight properties exist by using
.PN ChangeProperty 
requests to append zero-length data to each.
.LP
A client that stores data in the cut buffers (an owner) first must rotate the
ring of buffers by plus 1 by using
.PN RotateProperties 
requests to rename each buffer;
that is, CUT_BUFFER0 to CUT_BUFFER1, CUT_BUFFER1 to CUT_BUFFER2, .\^.\^.\|,
and CUT_BUFFER7 to CUT_BUFFER0.
It then must store the data into CUT_BUFFER0 by using a
.PN Change\%Property 
request in mode 
.PN Replace .
.LP
A client that obtains data from the cut buffers should use a
.PN GetProperty 
request to retrieve the contents of CUT_BUFFER0.
.LP
In response to a specific user request,
a client may rotate the cut buffers by minus 1 by using 
.PN RotateProperties 
requests to rename each buffer;
that is, CUT_BUFFER7 to CUT_BUFFER6, CUT_BUFFER6 to CUT_BUFFER5, .\^.\^.\|,
and CUT_BUFFER0 to CUT_BUFFER7.
.LP
Data should be stored to the cut buffers
and the ring rotated only when requested by explicit user action.
Users depend on their mental model of cut buffer operation
and need to be able to identify operations that transfer data to and fro.
.nH 1 "Client to Window Manager Communication"
.LP
To permit window managers to perform their role of mediating the competing
demands for resources such as screen space,
the clients being managed must adhere to certain conventions
and must expect the window managers to do likewise.
.mc |
These conventions are covered here from the client's point of view.
.mc
.LP
In general,
these conventions are somewhat complex
and will undoubtedly change as new window management paradigms are developed.
Thus, there is a strong bias toward defining only those conventions
that are essential and that apply generally to all window management paradigms.
Clients designed to run with a particular window manager can easily
define private protocols to add to these conventions,
but they must be aware that their users may decide to run some other
window manager no matter how much the designers of the private protocol
are convinced that they have seen the \*Qone true light\*U of user interfaces.
.LP
It is a principle of these conventions that a general client should
neither know nor care which window manager is running or, indeed, 
if one is running at all.
The conventions do not support all client functions 
without a window manager running;
for example, the concept of Iconic 
is not directly supported by clients.
If no window manager is running,
the concept of Iconic does not apply.
A goal of the conventions is to make it possible to kill and
restart window managers without loss of functionality.
.LP
Each window manager will implement a particular window management policy;
the choice of an appropriate window management policy
for the user's circumstances is not one for an individual client to
make but will be made by the user or the user's system administrator.
This does not exclude the possibility of writing clients that
use a private protocol to restrict themselves to operating only
under a specific window manager.
Rather, 
it merely ensures that no claim of general utility is made for such programs.
.LP
For example,
the claim is often made: 
\*QThe client I'm writing is important, and it needs to be on top.\*U
Perhaps it is important when it is being run in earnest,
and it should then be run under the control of a window manager 
that recognizes \*Qimportant\*U windows through some private protocol 
and ensures that they are on top.
However, imagine, for example, that the \*Qimportant\*U client is being debugged.
Then,  ensuring that it is always on top is no longer 
the appropriate window management policy,
and it should be run under a window manager that allows other windows 
(for example, the debugger) to appear on top.
.nH 2 "Client's Actions"
.LP
In general, 
the object of the X Version 11 design is that clients should,
as far as possible, do exactly what they would do in the absence 
of a window manager, except for the following:
.bP
Hinting to the window manager about the resources they would like
to obtain
.bP
Cooperating with the window manager by accepting the resources they
are allocated even if they are not those requested
.bP
Being prepared for resource allocations to change at any time
.nH 3 "Creating a Top-Level Window"
.mc |
.LP
A client's \fItop-level window\fP is a window whose override-redirect
attribute is
.PN False .
It must either be a child of a root window, or it must have been a child of
a root window immediately prior to having been reparented by the window
manager.  If the client reparents the window away from the root, the window
is no longer a top-level window; but it can become a top-level window again
if the client reparents it back to the root.
.mc
.LP
A client usually would expect to create its top-level windows
as children of one or more of the root windows by using some
boilerplate like the following:
.LP
.Ds 0
.TA 2i
.ta 2i
win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy), xsh.x, xsh.y, 
	xsh.width, xsh.height, bw, bd, bg);
.De
.LP
If a particular one of the root windows was required, however,
it could use something like the following:
.LP
.Ds 0
.TA 2i
.ta 2i
win = XCreateSimpleWindow(dpy, RootWindow(dpy, screen), xsh.x, xsh.y, 
	xsh.width, xsh.height, bw, bd, bg);
.De
.LP
Ideally,
it should be possible to override the choice of a root window 
and allow clients (including window managers) to treat a nonroot window 
as a pseudo-root.
This would allow, for example, the testing of window managers and the
use of application-specific window managers to control the subwindows
owned by the members of a related suite of clients.
Doing so properly requires an extension,
the design of which is under study.
.LP
From the client's point of view,
the window manager will regard its top-level window as being in 
one of three states:
.bP
Normal
.bP
Iconic
.bP
Withdrawn
.LP
Newly created windows start in the Withdrawn state.
Transitions between states happen when the top-level window is mapped
and unmapped and when the window manager receives certain messages.
For further details, see sections 4.1.2.4 and 4.1.4.
.nH 3 "Client Properties"
.LP
Once the client has one or more top-level windows, 
it should place properties on those windows to inform the window manager 
of the behavior that the client desires.
Window managers will assume values they find convenient 
for any of these properties that are not supplied;
clients that depend on particular values must explicitly supply them.
The window manager will not change properties written by the client.
.LP
The window manager will examine the contents of these
properties when the window makes the transition from the Withdrawn state
and will monitor some properties for changes while the window is 
in the Iconic or Normal state.
When the client changes one of these properties, 
it must use 
.PN Replace
mode to overwrite the entire property with new data;
the window manager will retain no memory of the old value of the property.
All fields of the property must be set to suitable values in a single 
.PN Replace
mode 
.PN ChangeProperty
request.
This ensures that the full contents of the property will be
available to a new window manager if the existing one crashes,
if it is shut down and restarted,
or if the session needs to be shut down and restarted by the session manager.
.NT Convention
Clients writing or rewriting window manager properties must
ensure that the entire content of each property remains valid
at all times.
.NE
.LP
.mc |
Some of these properties may contain the IDs of resources, such as
windows or pixmaps.  Clients should ensure that these resources exist
for at least as long as the window on which the property resides.
.LP
.mc
If these properties are longer than expected,
clients should ignore the remainder of the property.
Extending these properties is reserved to the X Consortium;
private extensions to them are forbidden.
Private additional communication between clients and window managers 
should take place using separate properties.
.mc |
The only exception to this rule is the WM_PROTOCOLS property, which may be
of arbitrary length and which may contain atoms representing private
protocols; see section 4.1.2.7.
.mc
.LP
The next sections describe each of the properties the clients
need to set, in turn.
They are summarized in the table in section 4.4.
.nH 4 "WM_NAME Property"
.LP
The WM_NAME property is an uninterpreted string 
that the client wants the window manager to display
in association with the window (for example, in a window headline bar).
.LP
The encoding used for this string 
(and all other uninterpreted string properties) 
is implied by the type of the property.
The type atoms to be used for this purpose are described in section 2.7.1.
.LP
Window managers are expected to make an effort to display this information.
Simply ignoring WM_NAME is not acceptable behavior.
Clients can assume that at least the first part of this string
is visible to the user and that if the information is not visible to the user,
it is because the user has taken an explicit action to make it invisible.
.LP
On the other hand,
there is no guarantee that the user can see the WM_NAME string 
even if the window manager supports window headlines.
The user may have placed the headline off-screen
or have covered it by other windows.
WM_NAME should not be used for application-critical information 
or to announce asynchronous changes of an application's state 
that require timely user response.
The expected uses are to permit the user to identify one of a
number of instances of the same client
and to provide the user with noncritical state information.
.LP
Even window managers that support headline bars will place some limit 
on the length of the WM_NAME string that can be visible;
brevity here will pay dividends.
.nH 4 "WM_ICON_NAME Property"
.LP
The WM_ICON_NAME property is an uninterpreted string 
that the client wants to be displayed in association with the window 
when it is iconified (for example, in an icon label).
In other respects, 
including the type, it is similar to WM_NAME.
For obvious geometric reasons,
fewer characters will normally be visible in WM_ICON_NAME than WM_NAME.
.LP
Clients should not attempt to display this string in their icon pixmaps
or windows; rather, they should rely on the window manager to do so.
.nH 4 "WM_NORMAL_HINTS Property"
.LP
The type of the WM_NORMAL_HINTS property is WM_SIZE_HINTS.
Its contents are as follows:
.br
.ne 6
.TS H
l l l.
_
.sp 6p
.B
Field	Type	Comments
.sp 6p
_
.sp 6p
.TH
.R
flags	CARD32	(see the next table)
pad	4*CARD32	For backwards compatibility
min_width	INT32	If missing, assume base_width
min_height	INT32	If missing, assume base_height
max_width	INT32
max_height	INT32
width_inc	INT32
height_inc	INT32
min_aspect	(INT32,INT32)
max_aspect	(INT32,INT32)
base_width	INT32	If missing, assume min_width
base_height	INT32	If missing, assume min_height
win_gravity	INT32	If missing, assume NorthWest
.sp 6p
_
.TE
.LP
The WM_SIZE_HINTS.flags bit definitions are as follows:
.br
.ne 6
.TS H
l n l.
_
.sp 6p
.B
Name	Value	Field
.sp 6p
_
.sp 6p
.TH
.R
USPosition	1	User-specified x, y
USSize	2	User-specified width, height
PPosition	4	Program-specified position
PSize	8	Program-specified size
PMinSize	16	Program-specified minimum size
PMaxSize	32	Program-specified maximum size
PResizeInc	64	Program-specified resize increments
PAspect	128	Program-specified min and max aspect ratios
PBaseSize	256	Program-specified base size
PWinGravity	512	Program-specified window gravity
.sp 6p
_
.TE
.LP
To indicate that the size and position of the window 
.mc |
(when a transition from the Withdrawn state occurs) was specified by the user, 
.mc
the client should set the
.PN USPosition
and
.PN USSize
flags, 
which allow a window manager to know that the user specifically asked where
the window should be placed or how the window should be sized and that
further interaction is superfluous.
To indicate that it was specified by the client without any user involvement,
the client should set 
.PN PPosition
and 
.PN PSize .
.LP
.mc |
The size specifiers refer to the width and height of the client's
window excluding borders.
.mc
.LP
.mc |
The win_gravity may be any of the values specified for WINGRAVITY in
the core protocol except for
.PN Unmap :
.mc
.PN NorthWest 
(1), 
.PN North 
(2), 
.PN NorthEast 
(3), 
.PN West 
(4), 
.PN Center
(5),
.PN East
(6), 
.PN SouthWest
(7),
.PN South
(8), and 
.PN SouthEast
.mc |
(9).  It specifies how and whether the client window wants to be shifted to
make room for the window manager frame.
.mc
.LP
.mc |
If the win_gravity is
.PN Static ,
the window manager frame is positioned
so that the inside border of the client window inside the frame is
in the same position on the screen as it was when the client
requested the transition from Withdrawn state.  Other values of
win_gravity specify a window reference point.  For
.PN NorthWest ,
.PN NorthEast ,
.PN SouthWest ,
and
.PN SouthEast
the reference point is the specified outer corner of the window (on the
outside border edge).  For
.PN North ,
.PN South ,
.PN East ,
and
.PN West
the reference point is the center of the specified outer edge of the window
border.  For
.PN Center
the reference point is the center of the window.  The reference point of the
window manager frame is placed at the location on the screen where the
reference point of the client window was when the client requested the
transition from Withdrawn state.
.LP
.mc
The min_width and min_height elements specify the
minimum size that the window can be for the client to be useful.
The max_width and max_height elements specify the maximum size.
The base_width and base_height elements in conjunction with width_inc
and height_inc define an arithmetic progression of preferred window
widths and heights for nonnegative integers \fIi\fP and \fIj\fP:
.LP
.Ds
.EQ C
width ~ = ~ base_width ~ + ~ ( i ~ times ~ width_inc )
.EN
.EQ C
height ~ = ~ base_height ~ + ~ ( j ~ times ~ height_inc )
.EN
.De
.LP
Window managers are encouraged to use \fIi\fP and \fIj\fP 
instead of width and height in reporting window sizes to users.
If a base size is not provided, 
the minimum size is to be used in its place and vice versa.
.LP
.mc |
The min_aspect and max_aspect fields are fractions with the numerator first
and the denominator second, and they allow a client to specify the range of
aspect ratios it prefers.  Window managers that honor aspect ratios should
take into account the base size in determining the preferred window size.  If
a base size is provided along with the aspect ratio fields, the base size
should be subtracted from the window size prior to checking that the aspect
ratio falls in range.  If a base size is not provided, nothing should be
subtracted from the window size.  (The minimum size is not to be used in
place of the base size for this purpose.)
.mc
.nH 4 "WM_HINTS Property"
.LP
The WM_HINTS property (whose type is WM_HINTS)
is used to communicate to the window manager.
It conveys the information the window manager needs 
other than the window geometry,
which is available from the window itself;
the constraints on that geometry,
which is available from the WM_NORMAL_HINTS structure;
and various strings,
which need separate properties, such as WM_NAME.
The contents of the properties are as follows:
.br
.ne 6
.TS H
l l l.
_
.sp 6p
.B
Field	Type	Comments
.sp 6p
_
.sp 6p
.TH
.R
flags	CARD32	(see the next table)
input	CARD32	The client's input model
initial_state	CARD32	The state when first mapped
icon_pixmap	PIXMAP	The pixmap for the icon image
icon_window	WINDOW	The window for the icon image
icon_x	INT32	The icon location
icon_y	INT32
icon_mask	PIXMAP	The mask for the icon shape
window_group	WINDOW	The ID of the group leader window
.sp 6p
_
.TE
.LP
The WM_HINTS.flags bit definitions are as follows:
.br
.ne 6
.TS H
l n l.
_
.sp 6p
.B
Name	Value	Field
.sp 6p
_
.sp 6p
.TH
.R
InputHint	1	input
StateHint	2	initial_state
IconPixmapHint	4	icon_pixmap
IconWindowHint	8	icon_window
IconPositionHint	16	icon_x & icon_y
IconMaskHint	32	icon_mask
WindowGroupHint	64	window_group
MessageHint	128	This bit is obsolete
.mc |
VisibleHint	256	visibility
.mc
.sp 6p
_
.TE
.LP
Window managers are free to assume convenient values for all fields of
the WM_HINTS property if a window is mapped without one.
.LP
The input field is used to communicate to the window manager the input focus
model used by the client (see section 4.1.7).
.LP
Clients with the Globally Active and No Input models should set the
input flag to
.PN False .
Clients with the Passive and Locally Active models should set the input
flag to
.PN True .
.LP
From the client's point of view, 
the window manager will regard the client's top-level window as being 
in one of three states:
.bP
Normal
.bP
Iconic
.bP
Withdrawn
.LP
The semantics of these states are described in section 4.1.4.
Newly created windows start in the Withdrawn state.
Transitions between states happen when a
top-level window is mapped and unmapped
and when the window manager receives certain messages.
.LP
The value of the initial_state field determines the state the client
wishes to be in at the time the top-level window is mapped 
from the Withdrawn state, as shown in the following table:
.br
.ne 6
.TS H
l n l.
_
.sp 6p
.B
State	Value	Comments
.sp 6p
_
.sp 6p
.TH
.R
NormalState	1	The window is visible
IconicState	3	The icon is visible
.sp 6p
_
.TE
.LP
The icon_pixmap field may specify a pixmap to be used as an icon.
This pixmap should be:
.bP
One of the sizes specified in the WM_ICON_SIZE property 
on the root if it exists (see section 4.1.3.2).
.bP
1-bit deep.
The window manager will select, through the defaults database,
suitable background (for the 0 bits) and foreground (for the 1 bits) colors.
These defaults can, of course, specify different colors for the icons 
of different clients.
.LP
The icon_mask specifies which pixels of the icon_pixmap should be used as the
icon, allowing for icons to appear nonrectangular.
.LP
The icon_window field is the ID of a window the client wants used as its icon.
Most, but not all, window managers will support icon windows.
Those that do not are likely to have a user interface in which small
windows that behave like icons are completely inappropriate.
Clients should not attempt to remedy the omission by working around it.
.LP
Clients that need more capabilities from the icons than a simple two-color
bitmap should use icon windows.
Rules for clients that do are set out in section 4.1.9.
.LP
The (icon_x,icon_y) coordinate is a hint to the window manager 
as to where it should position the icon.
The policies of the window manager control the positioning of icons,
so clients should not depend on attention being paid to this hint.
.LP
The window_group field lets the client specify that this window belongs 
to a group of windows.
An example is a single client manipulating multiple 
children of the root window.
.NT Conventions
.IP 1. 5
The window_group field should be set to the ID of the group leader.
The window group leader may be a window that exists only for that purpose;
a placeholder group leader of this kind would never be mapped
either by the client or by the window manager.
.IP 2. 5
The properties of the window group leader are those for the group as
a whole (for example, the icon to be shown when the entire group is iconified).
.NE
.LP
Window managers may provide facilities for manipulating the group as a whole.
Clients, at present, have no way to operate on the group as a whole.
.LP
The messages bit, if set in the flags field, indicates that the
client is using an obsolete window manager communication protocol,\**
rather than the WM_PROTOCOLS mechanism of section 4.1.2.7.
.FS
This obsolete protocol was described in the July 27, 1988
draft of the ICCCM.
Windows using it can also be detected because their WM_HINTS properties are
four bytes longer than expected.
Window managers are free to support clients using the obsolete protocol
in a \*Qbackwards compatibility\*U mode.
.FE
.LP
.mc |
The VisibleHint bit, if set in the flags field, indicates that the window
manager should try to make this window visible to the user.  This hint is
typically used for alarm dialog boxes.
.mc
.nH 4 "WM_CLASS Property"
.LP
The WM_CLASS property (of type STRING without control characters)
contains two consecutive null-terminated strings.
These specify the Instance and Class names to be used by both the client 
and the window manager for looking up resources for the application 
or as identifying information.
This property must be present when the window leaves the Withdrawn state
and may be changed only while the window is in the Withdrawn state.
Window managers may examine the property only when they start up 
and when the window leaves the Withdrawn state,
but there should be no need for a client to change its state dynamically.
.LP
The two strings, respectively, are:
.bP
A string that names the particular instance of the application to which
the client that owns this window belongs.
Resources that are specified by instance name override any resources
that are specified by class name.
Instance names can be specified by the user in an operating-system specific 
manner.
On POSIX-conformant systems,
the following conventions are used:
.RS
.IP \- 5
.mc |
If \*Q\-name NAME\*U is given on the command line,
.mc
NAME is used as the instance name.
.IP \- 5
Otherwise, if the environment variable RESOURCE_NAME is set,
its value will be used as the instance name.
.IP \- 5
Otherwise,
the trailing part of the name used to invoke the program
(argv[0] stripped of any directory names) is used as the instance name.
.RE
.bP
A string that names the general class of applications to which the client 
that owns this window belongs.
Resources that are specified by class apply to all applications 
that have the same class name.
Class names are specified by the application writer.
Examples of commonly used class names include: 
.mc |
\*QEmacs\*U, \*QXTerm\*U, \*QXClock\*U, \*QXLoad\*U, and so on.
.mc
.LP
Note that WM_CLASS strings are null-terminated
and, thus, differ from the general conventions that STRING properties 
are null-separated.
This inconsistency is necessary for backwards compatibility.
.nH 4 "WM_TRANSIENT_FOR Property"
.LP
The WM_TRANSIENT_FOR property (of type WINDOW)
contains the ID of another top-level window.
The implication is that this window is a pop-up on behalf of the named window,
and window managers may decide not to decorate transient windows
or may treat them differently in other ways.
In particular,
window managers should present newly mapped WM_TRANSIENT_FOR
windows without requiring any user interaction,
even if mapping top-level windows normally does require interaction.
Dialogue boxes, for example, are an example of windows that should have
WM_TRANSIENT_FOR set.
.LP
It is important not to confuse WM_TRANSIENT_FOR with override-redirect.
WM_TRANSIENT_FOR should be used in those cases where the pointer
is not grabbed while the window is mapped (in other words, 
if other windows are allowed to be active while the transient is up).
If other windows must be prevented from processing input
(for example, when implementing pop-up menus),
use override-redirect and grab the pointer while the window is mapped.
.nH 4 "WM_PROTOCOLS Property"
.LP
The WM_PROTOCOLS property (of type ATOM) is a list of atoms.
Each atom identifies a communication protocol between the client 
and the window manager in which the client is willing to participate.
Atoms can identify both standard protocols and private protocols
specific to individual window managers.
.LP
All the protocols in which a client can volunteer to take part 
involve the window manager sending the client a 
.PN ClientMessage
event and the client taking appropriate action.
For details of the contents of the event,
see section 4.2.8.
In each case,
the protocol transactions are initiated by the window manager.
.LP
The WM_PROTOCOLS property is not required.
If it is not present,
the client does not want to participate in any window manager protocols.
.LP
The X Consortium will maintain a registry of protocols to avoid collisions 
in the name space.
The following table lists the protocols that have been defined to date.
.br
.ne 6
.TS H
l c l.
_
.sp 6p
.B
Protocol	Section	Purpose
.sp 6p
_
.sp 6p
.TH
.R
WM_TAKE_FOCUS	4.1.7	Assignment of input focus
WM_SAVE_YOURSELF	Appendix C	Save client state request (deprecated)
WM_DELETE_WINDOW	4.2.8.1	Request to delete top-level window
.sp 6p
_
.TE
It is expected that this table will grow over time.
.nH 4 "WM_COLORMAP_WINDOWS Property"
.LP
The WM_COLORMAP_WINDOWS property (of type WINDOW) on a top-level window 
is a list of the IDs of windows that may need colormaps installed
that differ from the colormap of the top-level window.
The window manager will watch this list of windows for changes in their
colormap attributes.
The top-level window is always (implicitly or explicitly) on the watch list.
For the details of this mechanism,
see section 4.1.8.
.nH 4 "WM_CLIENT_MACHINE Property"
.mc |
.LP
The client should set the WM_CLIENT_MACHINE property (of one of the TEXT
types) to a string that forms the name of the machine running the client as
seen from the machine running the server.
.mc
.nH 3 "Window Manager Properties"
.LP
The properties that were described in the previous section are those 
that the client is responsible for maintaining on its top-level windows.
This section describes the properties that the window manager places on
client's top-level windows and on the root.
.nH 4 "WM_STATE Property"
.mc |
.LP
The window manager will place a WM_STATE property (of type WM_STATE) on each
top-level client window that is not in the Withdrawn state.  Top-level
windows in the Withdrawn state may or may not have the WM_STATE property.
Once the top-level window has been withdrawn, the client may re-use it for
another purpose.  Clients that do so should remove the WM_STATE property if
it is still present.
.LP
Some clients (such as \fBxprop\fP) will ask the user to click over a window
on which the program is to operate.  Typically, the intent is for this to be
a top-level window.  To find a top-level window, clients should search the
window hierarchy beneath the selected location for a window with the
WM_STATE property.  This search must be recursive in order to cover all
window manager reparenting possibilities.  If no window with a WM_STATE
property is found, it is recommended that programs use a mapped
child-of-root window if one is present beneath the selected location.
.LP
The contents of the WM_STATE property are defined as follows:
.br
.mc
.ne 6
.TS H
l l l.
_
.sp 6p
.B
Field	Type	Comments
.R
.sp 6p
_
.sp 6p
.TH
.mc |
state	CARD32	(see the next table)
icon	WINDOW	ID of icon window
.mc
.sp 6p
_
.TE
.LP
.mc |
The following table lists the WM_STATE.state values:
.br
.mc
.ne 6
.TS H
l n.
_
.sp 6p
.B
State	Value
.R
.sp 6p
_
.sp 6p
.TH
.mc |
WithdrawnState	0
NormalState	1
IconicState	3
.mc
.sp 6p
_
.TE
.LP
.mc |
Adding other fields to this property is reserved to the X Consortium.
Values for the state field other than those defined in the above
table are reserved for use by X Consortium.
.LP
The state field describes the window manager's idea of the state 
the window is in, which may not match the client's idea as expressed 
in the initial_state field of the WM_HINTS property 
(for example, if the user has asked the window manager to iconify the window).
If it is 
.PN Normal\%State ,
the window manager believes the client should be animating its window.
If it is 
.PN IconicState ,
the client should animate its icon window.
In either state,
clients should be prepared to handle exposure events from either window.
.LP
When the window is withdrawn, the window manager will either change the
state field's value to
.PN Withdrawn\%State
or it will remove the WM_STATE property entirely.
.LP
The icon field should contain the window ID of the window that the
window manager uses as the icon for the window on which this property is
set.  If no such window exists, the icon field should be
.PN None .
Note that this window could be but is not necessarily the same window as the
icon window that the client may have specified in its WM_HINTS property.
The WM_STATE icon may be a window that the window manager has supplied and
that contains the client's icon pixmap, or it may be an ancestor of the
client's icon window.
.mc
.nH 4 "WM_ICON_SIZE Property"
.LP
A window manager that wishes to place constraints on the sizes of icon
pixmaps and/or windows should place a property called WM_ICON_SIZE on the root.
The contents of this property are listed in the following table. 
.br
.ne 6
.TS H
l l l.
_
.sp 6p
.B
Field	Type	Comments
.sp 6p
_
.sp 6p
.TH
.R
min_width	CARD32	The data for the icon size series
min_height	CARD32
max_width	CARD32
max_height	CARD32
width_inc	CARD32
height_inc	CARD32
.sp 6p
_
.TE
.LP
For more details see section 14.1.12 in \fIXlib \- C Language X Interface\fP.
.nH 3 "Changing Window State"
.LP
From the client's point of view,
the window manager will regard each of the client's top-level 
windows as being in one of three states,
whose semantics are as follows:
.bP
.PN NormalState
.mc |
\- The client's top-level window is viewable.
.mc
.bP
.PN IconicState
\- The client's top-level window is iconic
(whatever that means for this window manager).
.mc |
The client can assume that its top-level window is not viewable,
its icon_window (if any) will be viewable
and, failing that, 
its icon_pixmap (if any) or its WM_ICON_NAME will be displayed.
.mc
.bP
.PN WithdrawnState
.mc |
\- Neither the client's top-level window nor its icon is visible.
.mc
.LP
In fact,
the window manager may implement states with semantics 
other than those described above.
For example,
.mc |
a window manager might implement a concept of an \*Qinactive\*U state
.mc
in which an infrequently used client's window would be represented 
as a string in a menu.
But this state is invisible to the client,
.mc |
which would see itself merely as being in the Iconic state.
.mc
.LP
Newly created top-level windows are in the Withdrawn state.
Once the window has been provided with suitable properties,
.mc |
the client is free to change its state as follows:
.mc
.bP
Withdrawn \(-> Normal \- The client should map the window with 
WM_HINTS.initial_state being 
.PN NormalState .
.bP
Withdrawn \(-> Iconic \- The client should map the window with 
WM_HINTS.initial_state being 
.PN IconicState .
.bP
.mc |
Normal \(-> Iconic \- The client should send a
.PN ClientMessage
event as described later in this section.
.mc
.bP
Normal \(-> Withdrawn \- The client should unmap the window and follow it 
with a synthetic 
.PN UnmapNotify
.mc |
event as described later in this section.
.mc
.bP
Iconic \(-> Normal \- The client should map the window.
The contents of WM_HINTS.initial_state are irrelevant in this case.
.bP
Iconic \(-> Withdrawn \- The client should unmap the window 
and follow it with a synthetic 
.PN UnmapNotify
.mc |
event as described later in this section.
.mc
.LP
.mc |
Only the client can effect a transition into or out of the Withdrawn
state.
Once a client's window
.mc
has left the Withdrawn state,
.mc |
the window will be mapped if it is in the Normal state and the window will be
unmapped if it is in the Iconic state.  Reparenting window managers
must unmap the client's window when it is in the Iconic state, even if an
ancestor window being unmapped renders the client's window unviewable.
Conversely, if a reparenting window manager renders the client's window
unviewable by unmapping an ancestor, the client's window is by definition in
the Iconic state and must also be unmapped.
.mc
.NT "Advice to Implementors"
.mc |
Clients can select for
.PN StructureNotify
on their
top-level windows to track transitions between Normal and Iconic states.
Receipt of a
.PN MapNotify
event will indicate a transition to the Normal state, and receipt of an
.PN UnmapNotify
event will indicate a transition to the Iconic state.
.NE
.mc
.LP
.mc |
When changing the state of the window to Withdrawn, the client must (in
